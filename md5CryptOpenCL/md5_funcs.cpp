#include "stdafx.h"
#include "types.h"
#include "md5_funcs.h"

#include <stdio.h>
#include <stdlib.h>

#ifdef __APPLE__
#include <OpenCL/opencl.h>
#else
#include <CL/cl.h>
#endif

#ifdef __unix__
#define OS_Windows 0
#define MAX_PATH 260
#include <unistd.h>
#elif defined(_WIN32) || defined(WIN32)
#define OS_Windows 1
#include <Windows.h>
#endif
#define ROUNDS_MD5CRYPT 1000

u8 int_to_itoa64(const u8 c)
{
	const u8 tbl[0x40] =
	{
		0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x41, 0x42, 0x43, 0x44,
		0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54,
		0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a,
		0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a,
	};

	return tbl[c];
}

u8 itoa64_to_int(const u8 c)
{
	const u8 tbl[0x100] =
	{
		0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21,
		0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31,
		0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x00, 0x01,
		0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a,
		0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a,
		0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x20, 0x21, 0x22, 0x23, 0x24,
		0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34,
		0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x00, 0x01, 0x02, 0x03, 0x04,
		0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14,
		0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24,
		0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34,
		0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x00, 0x01, 0x02, 0x03, 0x04,
		0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14,
		0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24,
		0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34,
		0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x00, 0x01, 0x02, 0x03, 0x04,
	};

	return tbl[c];
}

static void md5crypt_decode(u8 digest[16], u8 buf[22])
{
	int l;

	l = itoa64_to_int(buf[0]) << 0;
	l |= itoa64_to_int(buf[1]) << 6;
	l |= itoa64_to_int(buf[2]) << 12;
	l |= itoa64_to_int(buf[3]) << 18;

	digest[0] = (l >> 16) & 0xff;
	digest[6] = (l >> 8) & 0xff;
	digest[12] = (l >> 0) & 0xff;

	l = itoa64_to_int(buf[4]) << 0;
	l |= itoa64_to_int(buf[5]) << 6;
	l |= itoa64_to_int(buf[6]) << 12;
	l |= itoa64_to_int(buf[7]) << 18;

	digest[1] = (l >> 16) & 0xff;
	digest[7] = (l >> 8) & 0xff;
	digest[13] = (l >> 0) & 0xff;

	l = itoa64_to_int(buf[8]) << 0;
	l |= itoa64_to_int(buf[9]) << 6;
	l |= itoa64_to_int(buf[10]) << 12;
	l |= itoa64_to_int(buf[11]) << 18;

	digest[2] = (l >> 16) & 0xff;
	digest[8] = (l >> 8) & 0xff;
	digest[14] = (l >> 0) & 0xff;

	l = itoa64_to_int(buf[12]) << 0;
	l |= itoa64_to_int(buf[13]) << 6;
	l |= itoa64_to_int(buf[14]) << 12;
	l |= itoa64_to_int(buf[15]) << 18;

	digest[3] = (l >> 16) & 0xff;
	digest[9] = (l >> 8) & 0xff;
	digest[15] = (l >> 0) & 0xff;

	l = itoa64_to_int(buf[16]) << 0;
	l |= itoa64_to_int(buf[17]) << 6;
	l |= itoa64_to_int(buf[18]) << 12;
	l |= itoa64_to_int(buf[19]) << 18;

	digest[4] = (l >> 16) & 0xff;
	digest[10] = (l >> 8) & 0xff;
	digest[5] = (l >> 0) & 0xff;

	l = itoa64_to_int(buf[20]) << 0;
	l |= itoa64_to_int(buf[21]) << 6;

	digest[11] = (l >> 0) & 0xff;
}

static void md5crypt_encode(const u8 digest[16], u8 buf[22])
{
	int l;

	l = (digest[0] << 16) | (digest[6] << 8) | (digest[12] << 0);

	buf[0] = int_to_itoa64(l & 0x3f); l >>= 6;
	buf[1] = int_to_itoa64(l & 0x3f); l >>= 6;
	buf[2] = int_to_itoa64(l & 0x3f); l >>= 6;
	buf[3] = int_to_itoa64(l & 0x3f); //l >>= 6;

	l = (digest[1] << 16) | (digest[7] << 8) | (digest[13] << 0);

	buf[4] = int_to_itoa64(l & 0x3f); l >>= 6;
	buf[5] = int_to_itoa64(l & 0x3f); l >>= 6;
	buf[6] = int_to_itoa64(l & 0x3f); l >>= 6;
	buf[7] = int_to_itoa64(l & 0x3f); //l >>= 6;

	l = (digest[2] << 16) | (digest[8] << 8) | (digest[14] << 0);

	buf[8] = int_to_itoa64(l & 0x3f); l >>= 6;
	buf[9] = int_to_itoa64(l & 0x3f); l >>= 6;
	buf[10] = int_to_itoa64(l & 0x3f); l >>= 6;
	buf[11] = int_to_itoa64(l & 0x3f); //l >>= 6;

	l = (digest[3] << 16) | (digest[9] << 8) | (digest[15] << 0);

	buf[12] = int_to_itoa64(l & 0x3f); l >>= 6;
	buf[13] = int_to_itoa64(l & 0x3f); l >>= 6;
	buf[14] = int_to_itoa64(l & 0x3f); l >>= 6;
	buf[15] = int_to_itoa64(l & 0x3f); //l >>= 6;

	l = (digest[4] << 16) | (digest[10] << 8) | (digest[5] << 0);

	buf[16] = int_to_itoa64(l & 0x3f); l >>= 6;
	buf[17] = int_to_itoa64(l & 0x3f); l >>= 6;
	buf[18] = int_to_itoa64(l & 0x3f); l >>= 6;
	buf[19] = int_to_itoa64(l & 0x3f); //l >>= 6;

	l = (digest[11] << 0);

	buf[20] = int_to_itoa64(l & 0x3f); l >>= 6;
	buf[21] = int_to_itoa64(l & 0x3f); //l >>= 6;
}

int md5crypt_parse_hash(u8 *input_buf, u32 input_len, hash_t *hash_buf)
{
	if (input_len < 26) return -3; // (PARSER_GLOBAL_LENGTH);

	if (memcmp("$1$", input_buf, 3) != 0) return -10; // (PARSER_SIGNATURE_UNMATCHED);

	u32 *digest = (u32 *)hash_buf->digest;

	salt_t *salt = hash_buf->salt;

	u8 *salt_pos = input_buf + 3;

	u32 iterations_len = 0;

	if (memcmp(salt_pos, "rounds=", 7) == 0)
	{
		salt_pos += 7;

		for (iterations_len = 0; salt_pos[0] >= '0' && salt_pos[0] <= '9' && iterations_len < 7; iterations_len++, salt_pos += 1) continue;

		if (iterations_len == 0) return -8; // (PARSER_SALT_ITERATION);
		if (salt_pos[0] != '$') return -10; // (PARSER_SIGNATURE_UNMATCHED);

		salt_pos[0] = 0x0;

		salt->salt_iter = atoll((const char *)(salt_pos - iterations_len));

		salt_pos += 1;

		iterations_len += 8;
	}
	else
	{
		salt->salt_iter = ROUNDS_MD5CRYPT;
	}

	if (input_len > (34 + iterations_len)) return -3; // (PARSER_GLOBAL_LENGTH);

	u8 *hash_pos = (u8 *)strchr((const char *)salt_pos, '$');

	if (hash_pos == NULL) return -9; // (PARSER_SEPARATOR_UNMATCHED);

	u32 salt_len = hash_pos - salt_pos;

	if (salt_len > 8) return -8; // (PARSER_SALT_LENGTH);

	memcpy((u8 *)salt->salt_buf, salt_pos, salt_len);

	salt->salt_len = salt_len;

	hash_pos++;

	u32 hash_len = input_len - 3 - iterations_len - salt_len - 1;

	if (hash_len != 22) return -4; // (PARSER_HASH_LENGTH);

	md5crypt_decode((u8 *)digest, hash_pos);

	return 0; // (PARSER_OK);
}

